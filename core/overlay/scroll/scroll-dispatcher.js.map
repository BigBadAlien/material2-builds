{"version":3,"sources":["core/overlay/scroll/scroll-dispatcher.ts"],"names":[],"mappings":";;;;;;;;;OAAO,EAAC,UAAU,EAAC,MAAM,eAAe;OAEjC,EAAC,OAAO,EAAC,MAAM,cAAc;OAC7B,EAAC,UAAU,EAAC,MAAM,iBAAiB;OAEnC,+BAA+B;AAGtC;;;GAGG;AAEH;IAUE;QAVF,iBA8CC;QA7CC,8FAA8F;QAC9F,cAAS,GAAkB,IAAI,OAAO,EAAQ,CAAC;QAE/C;;;WAGG;QACH,yBAAoB,GAAsC,IAAI,OAAO,EAAE,CAAC;QAGtE,4FAA4F;QAC5F,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc,CAAC,CAAC;QAChF,UAAU,CAAC,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc,CAAC,CAAC;IACzE,CAAC;IAED;;;OAGG;IACH,mCAAQ,GAAR,UAAS,UAAsB;QAA/B,iBAGC;QAFC,IAAM,kBAAkB,GAAG,UAAU,CAAC,eAAe,EAAE,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc,CAAC,CAAC;QACxF,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;IAChE,CAAC;IAED;;OAEG;IACH,qCAAU,GAAV,UAAW,UAAsB;QAC/B,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,WAAW,EAAE,CAAC;QACxD,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACH,mCAAQ,GAAR;QACE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,CAAC;IACvC,CAAC;IAED,+DAA+D;IAC/D,kCAAO,GAAP;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;IA9CH;QAAC,UAAU,EAAE;;wBAAA;IA+Cb,uBAAC;AAAD,CA9CA,AA8CC,IAAA","file":"scroll-dispatcher.js","sourcesContent":["import {Injectable} from '@angular/core';\nimport {Scrollable} from './scrollable';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport 'rxjs/add/observable/fromEvent';\n\n\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\n@Injectable()\nexport class ScrollDispatcher {\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n  _scrolled: Subject<void> = new Subject<void>();\n\n  /**\n   * Map of all the scrollable references that are registered with the service and their\n   * scroll event subscriptions.\n   */\n  scrollableReferences: WeakMap<Scrollable, Subscription> = new WeakMap();\n\n  constructor() {\n    // By default, notify a scroll event when the document is scrolled or the window is resized.\n    Observable.fromEvent(window.document, 'scroll').subscribe(() => this._notify());\n    Observable.fromEvent(window, 'resize').subscribe(() => this._notify());\n  }\n\n  /**\n   * Registers a Scrollable with the service and listens for its scrolled events. When the\n   * scrollable is scrolled, the service emits the event in its scrolled observable.\n   */\n  register(scrollable: Scrollable): void {\n    const scrollSubscription = scrollable.elementScrolled().subscribe(() => this._notify());\n    this.scrollableReferences.set(scrollable, scrollSubscription);\n  }\n\n  /**\n   * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n   */\n  deregister(scrollable: Scrollable): void {\n    this.scrollableReferences.get(scrollable).unsubscribe();\n    this.scrollableReferences.delete(scrollable);\n  }\n\n  /**\n   * Returns an observable that emits an event whenever any of the registered Scrollable\n   * references (or window, document, or body) fire a scrolled event.\n   * TODO: Add an event limiter that includes throttle with the leading and trailing events.\n   */\n  scrolled(): Observable<void> {\n    return this._scrolled.asObservable();\n  }\n\n  /** Sends a notification that a scroll event has been fired. */\n  _notify() {\n    this._scrolled.next();\n  }\n}\n"]}