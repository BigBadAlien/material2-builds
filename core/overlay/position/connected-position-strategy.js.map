{"version":3,"sources":["core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","file":"connected-position-strategy.js","sourcesContent":["import {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler} from './viewport-ruler';\nimport {\n    ConnectionPositionPair,\n    OriginConnectionPosition,\n    OverlayConnectionPosition,\n    ConnectedOverlayPositionChange\n} from './connected-position';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class ConnectedPositionStrategy implements PositionStrategy {\n  private _dir = 'ltr';\n\n  /** The offset in pixels for the overlay connection point on the x-axis */\n  private _offsetX: number = 0;\n\n  /** The offset in pixels for the overlay connection point on the y-axis */\n  private _offsetY: number = 0;\n\n  /** Whether the we're dealing with an RTL context */\n  get _isRtl() {\n    return this._dir === 'rtl';\n  }\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  _preferredPositions: ConnectionPositionPair[] = [];\n\n  /** The origin element against which the overlay will be positioned. */\n  private _origin: HTMLElement;\n\n  private _onPositionChange:\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\n\n  /** Emits an event when the connection point changes. */\n  get onPositionChange(): Observable<ConnectedOverlayPositionChange> {\n    return this._onPositionChange.asObservable();\n  }\n\n  constructor(\n      private _connectedTo: ElementRef,\n      private _originPos: OriginConnectionPosition,\n      private _overlayPos: OverlayConnectionPosition,\n      private _viewportRuler: ViewportRuler) {\n    this._origin = this._connectedTo.nativeElement;\n    this.withFallbackPosition(_originPos, _overlayPos);\n  }\n\n  get positions() {\n    return this._preferredPositions;\n  }\n\n  /**\n   * To be used to for any cleanup after the element gets destroyed.\n   */\n  dispose() { }\n\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin fits on-screen.\n   * @docs-private\n   */\n  apply(element: HTMLElement): Promise<void> {\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    const originRect = this._origin.getBoundingClientRect();\n    const overlayRect = element.getBoundingClientRect();\n\n    // We use the viewport rect to determine whether a position would go off-screen.\n    const viewportRect = this._viewportRuler.getViewportRect();\n\n    // Fallback point if none of the fallbacks fit into the viewport.\n    let fallbackPoint: OverlayPoint = null;\n\n    // We want to place the overlay in the first of the preferred positions such that the\n    // overlay fits on-screen.\n    for (let pos of this._preferredPositions) {\n      // Get the (x, y) point of connection on the origin, and then use that to get the\n      // (top, left) coordinate for the overlay at `pos`.\n      let originPoint = this._getOriginConnectionPoint(originRect, pos);\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\n      if (overlayPoint.fitsInViewport) {\n        this._setElementPosition(element, overlayPoint);\n        this._onPositionChange.next(new ConnectedOverlayPositionChange(pos));\n        return Promise.resolve(null);\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n        fallbackPoint = overlayPoint;\n      }\n    }\n\n    // If none of the preferred positions were in the viewport, take the one\n    // with the largest visible area.\n    this._setElementPosition(element, fallbackPoint);\n\n    return Promise.resolve(null);\n  }\n\n  withFallbackPosition(\n      originPos: OriginConnectionPosition,\n      overlayPos: OverlayConnectionPosition): this {\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n    return this;\n  }\n\n  /** Sets the layout direction so the overlay's position can be adjusted to match. */\n  withDirection(dir: 'ltr' | 'rtl'): this {\n    this._dir = dir;\n    return this;\n  }\n\n  /** Sets an offset for the overlay's connection point on the x-axis */\n  withOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n\n  /** Sets an offset for the overlay's connection point on the y-axis */\n  withOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n\n  /**\n   * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n   * @param rect\n   */\n  private _getStartX(rect: ClientRect): number {\n    return this._isRtl ? rect.right : rect.left;\n  }\n\n  /**\n   * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n   * @param rect\n   */\n  private _getEndX(rect: ClientRect): number {\n    return this._isRtl ? rect.left : rect.right;\n  }\n\n\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   * @param originRect\n   * @param pos\n   */\n  private _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\n    const originStartX = this._getStartX(originRect);\n    const originEndX = this._getEndX(originRect);\n\n    let x: number;\n    if (pos.originX == 'center') {\n      x = originStartX + (originRect.width / 2);\n    } else {\n      x = pos.originX == 'start' ? originStartX : originEndX;\n    }\n\n    let y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + (originRect.height / 2);\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    return {x, y};\n  }\n\n\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected, as well as how much of the element\n   * would be inside the viewport at that position.\n   */\n  private _getOverlayPoint(\n      originPoint: Point,\n      overlayRect: ClientRect,\n      viewportRect: ClientRect,\n      pos: ConnectionPositionPair): OverlayPoint {\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n    // relative to the origin point.\n    let overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n    }\n\n    let overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    let x = originPoint.x + overlayStartX + this._offsetX;\n    let y = originPoint.y + overlayStartY + this._offsetY;\n\n    // How much the overlay would overflow at this position, on each side.\n    let leftOverflow = viewportRect.left - x;\n    let rightOverflow = (x + overlayRect.width) - viewportRect.right;\n    let topOverflow = viewportRect.top - y;\n    let bottomOverflow = (y + overlayRect.height) - viewportRect.bottom;\n\n    // Visible parts of the element on each axis.\n    let visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n    let visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n\n    // The area of the element that's within the viewport.\n    let visibleArea = visibleWidth * visibleHeight;\n    let fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n\n    return {x, y, fitsInViewport, visibleArea};\n  }\n\n  /**\n   * Physically positions the overlay element to the given coordinate.\n   * @param element\n   * @param overlayPoint\n   */\n  private _setElementPosition(element: HTMLElement, overlayPoint: Point) {\n    element.style.left = overlayPoint.x + 'px';\n    element.style.top = overlayPoint.y + 'px';\n  }\n\n  /**\n   * Subtracts the amount that an element is overflowing on an axis from it's length.\n   */\n  private _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n}\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n};\n\n/**\n * Expands the simple (x, y) coordinate by adding info about whether the\n * element would fit inside the viewport at that position, as well as\n * how much of the element would be visible.\n */\ninterface OverlayPoint extends Point {\n  visibleArea?: number;\n  fitsInViewport?: boolean;\n}\n"]}