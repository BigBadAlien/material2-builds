{"version":3,"sources":["../../../src/lib/autocomplete/autocomplete-trigger.ts"],"names":[],"mappings":"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","file":"autocomplete-trigger.js","sourcesContent":["import {\n  Directive, ElementRef, Input, ViewContainerRef, Optional, OnDestroy\n} from '@angular/core';\nimport {NgControl} from '@angular/forms';\nimport {Overlay, OverlayRef, OverlayState, TemplatePortal} from '../core';\nimport {MdAutocomplete} from './autocomplete';\nimport {PositionStrategy} from '../core/overlay/position/position-strategy';\nimport {Observable} from 'rxjs/Observable';\nimport {MdOptionSelectEvent} from '../core/option/option';\nimport 'rxjs/add/observable/merge';\nimport {Dir} from '../core/rtl/dir';\nimport 'rxjs/add/operator/startWith';\nimport 'rxjs/add/operator/switchMap';\n\n\n/** The panel needs a slight y-offset to ensure the input underline displays. */\nexport const MD_AUTOCOMPLETE_PANEL_OFFSET = 6;\n\n@Directive({\n  selector: 'input[mdAutocomplete], input[matAutocomplete]',\n  host: {\n    '(focus)': 'openPanel()'\n  }\n})\nexport class MdAutocompleteTrigger implements OnDestroy {\n  private _overlayRef: OverlayRef;\n  private _portal: TemplatePortal;\n  private _panelOpen: boolean = false;\n\n  /* The autocomplete panel to be attached to this trigger. */\n  @Input('mdAutocomplete') autocomplete: MdAutocomplete;\n\n  constructor(private _element: ElementRef, private _overlay: Overlay,\n              private _viewContainerRef: ViewContainerRef,\n              @Optional() private _controlDir: NgControl, @Optional() private _dir: Dir) {}\n\n  ngOnDestroy() { this._destroyPanel(); }\n\n  /* Whether or not the autocomplete panel is open. */\n  get panelOpen(): boolean {\n    return this._panelOpen;\n  }\n\n  /** Opens the autocomplete suggestion panel. */\n  openPanel(): void {\n    if (!this._overlayRef) {\n      this._createOverlay();\n    }\n\n    if (!this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._portal);\n      this._subscribeToClosingActions();\n    }\n\n    this._panelOpen = true;\n  }\n\n  /** Closes the autocomplete suggestion panel. */\n  closePanel(): void {\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n    }\n\n    this._panelOpen = false;\n  }\n\n  /**\n   * A stream of actions that should close the autocomplete panel, including\n   * when an option is selected and when the backdrop is clicked.\n   */\n  get panelClosingActions(): Observable<any> {\n    // TODO(kara): add tab event observable with keyboard event PR\n    return Observable.merge(...this.optionSelections, this._overlayRef.backdropClick());\n  }\n\n  /** Stream of autocomplete option selections. */\n  get optionSelections(): Observable<any>[] {\n    return this.autocomplete.options.map(option => option.onSelect);\n  }\n\n\n  /**\n   * This method listens to a stream of panel closing actions and resets the\n   * stream every time the option list changes.\n   */\n  private _subscribeToClosingActions(): void {\n    // Every time the option list changes...\n    this.autocomplete.options.changes\n    // and also at initialization, before there are any option changes...\n        .startWith(null)\n        // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        .switchMap(() => this.panelClosingActions)\n        // when the first closing event occurs...\n        .first()\n        // set the value, close the panel, and complete.\n        .subscribe(event => this._setValueAndClose(event));\n  }\n\n  /** Destroys the autocomplete suggestion panel. */\n  private _destroyPanel(): void {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n   /**\n   * This method closes the panel, and if a value is specified, also sets the associated\n   * control to that value. It will also mark the control as dirty if this interaction\n   * stemmed from the user.\n   */\n  private _setValueAndClose(event: MdOptionSelectEvent | null): void {\n    if (event) {\n      this._controlDir.control.setValue(event.source.value);\n      if (event.isUserInput) {\n        this._controlDir.control.markAsDirty();\n      }\n    }\n\n    this.closePanel();\n  }\n\n  private _createOverlay(): void {\n    this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n    this._overlayRef = this._overlay.create(this._getOverlayConfig());\n  }\n\n  private _getOverlayConfig(): OverlayState {\n    const overlayState = new OverlayState();\n    overlayState.positionStrategy = this._getOverlayPosition();\n    overlayState.width = this._getHostWidth();\n    overlayState.hasBackdrop = true;\n    overlayState.backdropClass = 'md-overlay-transparent-backdrop';\n    overlayState.direction = this._dir ? this._dir.value : 'ltr';\n    return overlayState;\n  }\n\n  private _getOverlayPosition(): PositionStrategy {\n    return this._overlay.position().connectedTo(\n        this._element,\n        {originX: 'start', originY: 'bottom'}, {overlayX: 'start', overlayY: 'top'})\n        .withOffsetY(MD_AUTOCOMPLETE_PANEL_OFFSET);\n  }\n\n  /** Returns the width of the input element, so the panel width can match it. */\n  private _getHostWidth(): number {\n    return this._element.nativeElement.getBoundingClientRect().width;\n  }\n\n}\n\n"]}